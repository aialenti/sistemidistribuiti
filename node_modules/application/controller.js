/* 
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

var model = require('./model.js');
var errorsHandler = require('./errorHandling.js');
var crypto = require('./libs/md5.js');
var bcrypt = require('bcrypt');

var authorized = [];

//callback da eseguire dopo la query
callback = function(rows){
  }

//esecuzione della query
//model.executeQuery(query,callback);

var getIndex = function(req,res){
  //res.render('index');
  res.sendfile('views/matchview.html');
}

// Creazione nuovo utente
var createNewUser = function(req,res){
  model.req = req;
  var query;
  var username = model.getParam('username');
  var email = model.getParam('email');
  var password = model.getParam('password');
  
  // Critta la password con bcrypt
  var hashedpassword = bcrypt.hashSync(password, 10);
  
  var data = new Object();
  data.table = 'users';

  data.values = [
  ['username',username],
  ['email',email],
  ['password',hashedpassword]
  ];

  query = model.insertQuery(data);
  // Esegue la query e porta alla schermata di login (soluzione temporanea)
  model.executeQuery(query, function(){
    res.render('login');
  });
}

var doLogin = function(data, socket) {
  var query;
  var username = data.user;
  var password = data.password;
  var id = data.sessionid.express_sid;

  var data = new Object();
  data.from = 'users';

  data.select = ['*'];

  data.where = [
  ['username','=', username],
  ];
  query = model.searchQuery(data);
  var user;
  model.executeQuery(query, function(data){
    var errormessage;
    user = data;
    if (data.length != 0) {
      if (bcrypt.compareSync(password, user[0].password)) {
        errormessage = "ok";
        authorized.push(id);
        socket.emit('successfullogin', errormessage);
      }
      else {
        errormessage = "Wrong password!"
        socket.emit('loginerror',  errormessage);
      }
    }
    else {
      errormessage = "User does not exist!";
      socket.emit('loginerror', errormessage);
    }
  });
/*
   * Commento: una volta effettuata la query, si analizzano i risultati
   * (funzione di callback): se non si ottiene niente (data.length === 0)
   * vuol dire che non c'è un user con quell'username nel DB;
   * altrimenti, si controlla la correttezza della password con bcrypt
   * e si conferma o meno la validità del login (il messaggio passa alla pagina per il rendering)
   */
}

var authorize = function(sid) {
  var auth = false;
  if (authorized != undefined)
    for (var i = 0;i < authorized.length; i++) {
      if (sid===authorized[i]) {
        auth = true;
      }
    }
  return auth;
}

var manageMatch = function(req, res) {
  model.req = req; //in questo modo non devo inserire req in tutte le chiamate a getParam;
  var query;
  var action = model.getParam("action");
  var currentDay = model.getParam("day");
  var home_team = model.getParam('home_team');
  var away_team = model.getParam('away_team');
  var matchdays_flag = model.getParam('matchdays_flag');
  var matchdays_number = model.getParam('matchdays_number');
  var matchdays_season = model.getParam('matchdays_season');
  var id = model.getParam('id');
  
  var data = new Object();
  data.table = "matches";
  
  switch(action){
    case "create":
      data.values = [
      ["home_team",home_team],
      ["away_team",away_team],
      ["matchdays_flag",matchdays_flag],
      ["matchdays_number",matchdays_number],
      ["matchdays_season",matchdays_season]
      ]
      query = model.insertQuery(data);
      break;
    case "delete":
      data.where = [
      ["id","=",id]
      ];
      query = model.deleteQuery(data);
      break;
    case "edit":
      data.values = [
      ["home_team",home_team],
      ["away_team",away_team],
      ["matchdays_flag",matchdays_flag],
      ["matchdays_number",matchdays_number],
      ["matchdays_season",matchdays_season]
      ]
      data.where = [
      ["id","=",id]
      ];
      query = model.updateQuery(data);
      break;
    default:
      break;
  }
  model.executeQuery(query,function(error, rows, cols){
    
    });

}

var manageScore = function(req, socket) {
  model.req = req; //in questo modo non devo inserire req in tutte le chiamate a getParam;
  var query;
  var action = model.getParam("action");
  var data = new Object();
  data.values = model.getParam('values');
  console.log(data)
  var matchid = model.getParam("matchid");
  var scoreid = model.getParam("scoreid");
  var time = model.getParam("time");
  var player = model.getParam("player");
  //mi serve il matchid, conviene passarlo come parametro a aprte
  data.table = "scores";
  switch(action){
    case "create":
      query = model.insertQuery(data);
      break;
    case "delete":
      data.where = [
      ["id","=",scoreid]
      ];
      query = model.deleteQuery(data);
      console.log(query)
      break;
    case "update":
      console.log("###########àà")
      console.log(time)
      console.log(player)
      console.log("###########àà")
      if(time==false)
        time = "";
      if(player==false)
        player = ""
      data.values = [
      ["time",time],
      ["player",player]
      ]
      data.where = [
      ["id","=",scoreid]
      ];
      query = model.updateQuery(data);
      break;
    default:
      break;
  }
  model.executeQuery(query,function(error, rows, cols){
    var d = new Object;
    d.from = "matches";
    d.select = ["matchdays_number","matchdays_season"];
    d.where = [
    ["id","=",matchid+""]
    ];
    var query = model.searchQuery(d);
    model.executeQuery(query,function(rows,err,cols){
      var data = new Object();
      data.matchday_number = rows[0].matchdays_number;
      data.season = rows[0].matchdays_season;
      getMatchday(data,socket);
          
    });
  });

}

var manageMatchDay = function(req, res) {
  model.req = req; //in questo modo non devo inserire req in tutte le chiamate a getParam;
  var query;
  var action = model.getParam("action");
  var flag = model.getParam('flag');
  var number = model.getParam('number');
  var season = model.getParam('season');
  
  var new_flag = model.getParam("new_flag");
  var new_number = model.getParam('new_number');
  var new_season = model.getParam('new_season');
  
  var data = new Object();
  data.table = "matchdays";
  switch(action){
    case "create":
      data.values = [
      ["flag",flag],
      ["number",number],
      ["season",season]
      ]
      query = model.insertQuery(data);
      break;
    case "delete":
      data.where = [
      ["number","=",number],
      ["season","=",season],
      ["flag","=",flag]
      ];
      query = model.deleteQuery(data);
      break;
    case "edit":
      data.values = [
      ["number","=",new_number],
      ["season","=",new_season],
      ["flag","=",new_flag]
      ];
      data.where = [
      ["number","=",number],
      ["season","=",season],
      ["flag","=",flag]
      ];
      query = model.updateQuery(data);
      break;
    default:
      break;
  }
  model.executeQuery(query,function(error, rows, cols){
    });

}



var getChampionship = function(req,socket){
  var query = "";
  var data = new Object;
  data.select = ["*"];
  data.from = "teams";
  data.where = [];
  query = model.searchQuery(data);
  if(query != "")
    model.executeQuery(query,function(rows,error,cols){
      var ret = new Object;
      ret.rows = rows;
      ret.table = "teams";
      socket.emit("hereYourList",ret);
    });
  data.from = "matchdays";
  data.options = "group by season";
  query = model.searchQuery(data);
  if(query != "")
    model.executeQuery(query,function(rows,error,cols){
      var ret = new Object;
      ret.rows = rows;
      ret.table = "matchdays";
      socket.emit("hereYourList",ret);
    });
  
}

var manageTeam = function(req,socket) {
  var query;
  var action = req.action;
  var id = req.id;
  var name = req.name;
  
  var data = new Object();
  data.table = "teams";
  
  switch(action){
    case "create":
      data.values = [
      ["name",name]
      ]
      query = model.insertQuery(data);
      model.executeQuery(query,function(error, rows, cols){
        socket.emit("teamAdded")
      });
      break;
    case "delete":
      data.where = [
      ["id","=",id]
      ];
      query = model.deleteQuery(data);
      model.executeQuery(query,function(error, rows, cols){
        socket.emit("teamRemoved");
      });
      break;
    case "edit":
      data.values = [
      ["name",name]
      ];
      data.where = [
      ["id","=",id]
      ];
      
      query = model.updateQuery(data);
      break;
    default:
      break;
  }
  

}

var createSeason = function(req,socket){
  var list = req.list;
  var arrSquadre = list;
  console.log(arrSquadre);
  var query = "";
  var data = new Object;
  var new_season = req.year;
  var ns_error = errorsHandler.onlyNumbersFourDigits(new_season,true);
  var l_error = errorsHandler.emptyList(list,2);
  if(ns_error.status == true || l_error.status == true){
    error = new Object;
    error.year = ns_error;
    error.list = l_error;
    error.caller = "createSeason";
    ns_error.caller = "createSeason";
    socket.emit("errorOnSentData",error);
    return;
  }
  (arrSquadre.length % 2 ) && arrSquadre.push('0');
  data.values = new Array();
  query = "";
  //creazione delle giornate
  for(var i=0;i<(arrSquadre.length-1)*2;i++){
    if(i<arrSquadre.length-1)
      flag="0";
    else flag ="1";
    data.table = "matchdays"
    data.values[i] = [
    ["season",new_season+""],
    ["number",""+i],
    ["flag",flag]
    ]
  }
  query = model.multiInsertQuery(data);
  model.executeQuery(query,function(rows,error,cols){
    query = "";
    data.table = "matches";
    data.values = new Array();
    var p=0;
    var ht,at,flag,matchdays_number;
    // Aggiunta di una "squadra" di comodo se sono dispari 
    
    for (var i = 0; i < arrSquadre.length-1; i++) {
      for (var j = 0; j < arrSquadre.length/2 ; j++) {
        // alterna le partite in casa e fuori
        matchdays_number = i;
        if(i % 2 ===0){
          ht = arrSquadre[arrSquadre.length -j -1];
          at= arrSquadre[j];
        }
        else{
          ht = arrSquadre[j];
          at = arrSquadre[arrSquadre.length -j -1];
        }
        data.values[p] = [
        ["home_team",""+ht],
        ["away_team",""+at],
        ["matchdays_season",""+new_season],
        ["matchdays_number",matchdays_number+""],
        ["matchdays_flag","0"]
        ];  
        p++;
        data.values[p] = [
        ["home_team",""+at],
        ["away_team",""+ht],
        ["matchdays_season",""+new_season],
        ["matchdays_number",""+(matchdays_number+(arrSquadre.length-1))],
        ["matchdays_flag","1"]
        ];
        p++;
      }
      // Ultima squadra viene inserita nella posizione 1
      arrSquadre.splice(1,0,arrSquadre.pop());
          

    }
 
    query = model.multiInsertQuery(data);
    model.executeQuery(query,function(rows,error,cols){
      socket.emit("seasonCreated",rows);
    });
  });
}

var getChampionshipModalData = function(req,socket){
  var data = new Object;
  data.select = ["*"];
  data.from = "teams";
  data.where = [];
  var query = model.searchQuery(data);
  model.executeQuery(query,function(rows,error,cols){
    socket.emit("hereChampionshipModalData",rows);
  });
}


var getAdminPage = function(req,res){
  model.req = req;
  res.sendfile('views/admin.html');
}

var getSeasons = function(req,socket) {
  var query = "SELECT season FROM matchdays GROUP BY season ORDER BY season DESC";
  model.executeQuery(query, function(rows, error, cols) {
    console.log(rows);
    socket.emit("hereSeasonsList",rows);
  });
}

var getAllTheSeason = function(req,socket){
  model.req = req;
  var ret = new Array();
  var season = model.getParam("season");
  var query = "SELECT m.id,m.home_team, m.away_team,m.matchdays_flag,m.matchdays_number,m.matchdays_season,t.name as home_team_name,t2.name as away_team_name \n\
               FROM matches m,teams t,teams t2 \n\
               WHERE m.home_team = t.id AND m.away_team = t2.id AND m.matchdays_season='"+season+"' ORDER BY m.matchdays_number ASC";
  model.executeQuery(query,function(rows,error,cols){
    socket.emit("hereTheScores",rows);
  });
}

var getMatchday = function(data,socket){
  //oltre a tornare le scores deve ritornare anche le giornate che non hanno punteggi.
  //Bisogna vedere come utilizzare i risultati. Ci vorrebbe una funzione che becca solo le score
  var matchday = data.matchday_number;
  var season = data.season;
  var query = "SELECT m.id,m.home_team, m.away_team,m.matchdays_flag,m.matchdays_number,m.matchdays_season,t.name as home_team_name,t2.name as away_team_name \n\
               FROM matches m,teams t,teams t2 \n\
               WHERE m.home_team = t.id AND m.away_team = t2.id AND m.matchdays_season='"+season+"' AND m.matchdays_number = '"+matchday+"' ORDER BY m.home_team ASC";
  model.executeQuery(query,function(rows2,error,cols){
    var query = "SELECT m.id,m.home_team, m.away_team,m.matchdays_flag,m.matchdays_number,m.matchdays_season,t.name as home_team_name,t2.name as away_team_name,s.time,s.player,s.id as score_id,s.flag as score_flag  \n\
             FROM matches m,teams t,teams t2,scores s \n\
             WHERE m.id=s.match_id AND m.home_team = t.id AND m.away_team = t2.id AND m.matchdays_number ='"+matchday+"' AND m.matchdays_season = '"+season+"' ORDER BY s.time DESC";
  
    model.executeQuery(query,function(rows,error,cols){
      var returns = new Array();
      returns[0] = rows2;
      returns[1] = rows;
      if(data.onlyupdate != true)
        socket.emit("hereSelectMatchdayChange",returns);
      else
        socket.emit("updateScoresView",returns)
    });
  });
}

exports.getSeasons = getSeasons;
exports.getMatchday = getMatchday;
exports.getAllTheSeason = getAllTheSeason;
exports.createSeason = createSeason;
exports.getChampionshipModalData = getChampionshipModalData;
exports.getChampionship = getChampionship;
exports.getAdminPage = getAdminPage;
exports.getIndex = getIndex;
exports.doLogin = doLogin;
exports.manageMatch = manageMatch;
exports.manageMatchDay = manageMatchDay;
exports.manageScore = manageScore;
exports.manageTeam = manageTeam;
exports.createNewUser = createNewUser;
exports.authorize = authorize;
